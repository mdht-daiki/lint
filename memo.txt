https://qiita.com/square1001/items/1aa12e04934b6e749962

大きい整数を一桁の整数の配列として表現する
N桁の整数A -> 長さNの整数の配列a = a[0], a[1], a[2], ...
A = a[0] + a[1] * 10^1 + a[2] * 10^2 + a[N-1] * 10^(N-1)
16777216 = {6, 1, 2, 7, 7, 7, 6, 1}

文字列をint型配列に変換する関数
string_to_lint
引数：文字列S
戻り値：配列digit
N：文字列の長さ
要素数Nのint型配列digitを作成する
digitのi番目の要素に10^iの位の数字を代入する
10^iの位はSの何文字目？

strlenの戻り値は'\0'を含まない長さなので、
N=strlen(S)=5
  6       3       3       4       2       '\0'
  10^4    10^3    10^2    10^1    10^0    
  1文字目 2文字目 3文字目 4文字目 5文字目 6文字目
  S[0]    S[1]    S[2]    S[3]    S[4]    

i     N-i   N-i-1
0     5     4
1     4     3
2     3     2
3     2     1
4     1     0

よってdigit[i] = S[N-i-1]を整数に変形したもの
数字を整数に変形するには数字-'0'の演算をすればよい
よってdigit[i] = S[N-i-1] - '0'
これをi=0からi<Nの範囲で繰り返す

文字列がint型配列に変換できるものか確認する
check_string
引数：文字列S
戻り値：変換可能->1, 変換不可->0
N：文字列の長さ
for(i=0; i<N; i++)
S[i]が整数ではない場合、0を返す

S[i]が整数を含まない
-> S[i] < '0' または S[i] > '9'

符号による分岐
足し算 a + b
a > 0 && b > 0
  a + b > 0
  ans.digit = a.digit + b.digit
a > 0 && b < 0
  a.digit > b.digit
    a + b > 0
    ans.digit = a.digit - b.digit;
  a.digit < b.digit
    a + b < 0
    ans.digit = b.digit - a.digit;
a < 0 && b > 0
  a.digit > b.digit
    a + b < 0
    ans.digit = a.digit - b.digit;
  a.digit < b.digit
    a + b > 0
    ans.digit = b.digit - a.digit;
a < 0 && b < 0
  a + b < 0
  ans.digit = a.digit + b.digit;


引き算 a - b
a > b --> a - b > 0   ans.sign_pm = PLUS
  a > b > 0
    ans.digit = a.digit - b.digit
  a > 0 > b                           a.sign_pm != b.sign_pm -> ans = a + b
    ans.digit = a.digit + b.digit
  0 > a > b
    ans.digit = b.digit - a.digit

a < b --> a - b < 0   ams.sign_pm = MINUS
  b > a > 0
    ans.digit = b.digit - a.digit
  b > 0 > a
    ans.digit = a.digit + b.digit;
  0 > b > a
    ans.digit = a.digit - b.digit;

符号が違う場合
計算結果の絶対値は絶対値の和
符号が同じ場合
計算結果の絶対値は絶対値の差の絶対値
すなわちa,bのうち絶対値が大きい方の絶対値から小さい方の絶対値を引いたもの
aの絶対値 > bの絶対値のとき ans = a - b
bの絶対値 > aの絶対値のとき ans = b - a

S = "-87432"
strlen(S) = 6
i = 0; i < 6; i++
  for(int i = 0; i < l.length; i++) {
    if(S[l.length - i - 1] == '-')
      l.sign_pm = MINUS;
    else
      l.digit[i] = S[l.length - i - 1] - '0';
  }
  l.digit[l.length] = LINT_END;   /* 番兵 */
  return l;
}
length = 6
i = 0
S[5] = '2'
l.digit[0] = 2
i = 1
S[4] = '3'
l.digit[1] = 3
i = 2
S[3] = '4'
l.digit[2] = 4
i = 3
S[2] = '7'
l.digit[3] = 7
i = 4
S[1] = '8'
l.digit[4] = 8
i = 5
S[0] = '-'
l.sign_pm = MINUS;
l.digit[6] = LINT_END
2, 3, 4, 7, 8, ???, LINT_END